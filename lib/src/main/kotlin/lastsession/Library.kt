/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package lastsession

class Library {
    fun someLibraryMethod(): Boolean {
        return true
    }
}

enum class CellState { Alive, Dead}
data class Position(val x:Int, val y:Int)
data class Cell(val position: Position, val state:CellState)
data class Board(val cells:Map<Position, Cell>) {

    fun getNeighboursAt(pos: Position): List<Cell> {
        return listOf(
            getCellAt(pos.copy(pos.x-1)),
            getCellAt(pos.copy(pos.x+1)),
            getCellAt(pos.copy(pos.y-1)),
            getCellAt(pos.copy(pos.y-1)),
            getCellAt(pos.copy(pos.x-1, pos.y-1)),
            getCellAt(pos.copy(pos.x+1, pos.y-1)),
            getCellAt(pos.copy(pos.x-1, pos.y+1)),
            getCellAt(pos.copy(pos.x+1, pos.y+1)),
        ).filterNotNull()
    }

    fun getCellAt(pos: Position):Cell? {
        return cells[pos]
    }

    fun nextStateAt(pos: Position): Cell {
        val aliveNeighbours:Int = getNeighboursAt(pos).count {
            it.state == CellState.Alive
        }

        val newState = when(getCellAt(pos)!!.state) {
            CellState.Alive -> when (aliveNeighbours) {
                2,3 -> CellState.Alive
                else -> CellState.Dead
            }
            CellState.Dead -> if (aliveNeighbours == 3) CellState.Alive else CellState.Dead
        }

        // apply rules
        return Cell(pos, newState)
    }


    fun nextState():Board {
        val nextCells = cells
            .map { it.key to nextStateAt(it.key) }
            .toMap()
        return Board(nextCells)

    }

    fun printState() = println(cells.values)

}

fun emptyBoardOfSize(size:Int): Board {

    val cells = mutableMapOf<Position,Cell>()
    for (i in 0..size - 1) {
        for (j in 0..size - 1) {
            val position = Position(i,j)
            cells[position] = Cell(position, CellState.Dead)
        }

    }

    return Board(cells)
}




